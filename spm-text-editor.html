<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SPM Text Preview</title>
  <link rel="stylesheet" href="stylesheet.css">
  <style>

    @font-face {
      font-family: 'SPMText';
      src: url('PopJoyStd-B.ttf') format('truetype');
      font-weight: normal;
      font-style: normal;
    }

    body, #output {
      font-family: 'SPMText', sans-serif;
    }

    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 2rem;
      background: #f4f4f4;
    }
    textarea {
      width: 80%;
      height: 200px;
      margin-bottom: 1rem;
      font-family: 'SPMText', sans-serif;
      font-size: 1rem;
    }
    #output {
      width: 80%;
      min-height: 100px;
      background: white;
      padding: 1rem;
      border: 1px solid #ccc;
      white-space: pre-wrap;
    }
    .shake-letter { display:inline-block; animation:shake 0.15s infinite; }
    .wave-letter { display:inline-block; animation:wave 0.9s infinite; }
    @keyframes shake {
      0% {transform:translate(0,0)rotate(0)}
      20% {transform:translate(-0.5px,-0.5px)rotate(-1deg)}
      40% {transform:translate(-0.5px,0.5px)rotate(1deg)}
      60% {transform:translate(0.5px,0.5px)rotate(0)}
      80% {transform:translate(0.5px,-0.5px)rotate(1deg)}
      100% {transform:translate(0,0)rotate(-1deg)}
    }
    @keyframes wave {
      0% {transform:translateY(-3px)}
      50% {transform:translateY(3px)}
      100% {transform:translateY(-3px)}
    }
  </style>
</head>
<body>
  <h1>Super Paper Mario Text Preview</h1>
  <textarea id="input" placeholder="Use formatting from Super Paper Mario! Supports <shake>, <wave>, and <scale x>!"></textarea>
  <div id="output"></div>
  <script>
    const inputArea = document.getElementById('input');
    const outputDiv = document.getElementById('output');

    function createSpan(char, effects, scale, delay) {
      const textNode = document.createTextNode(char === ' ' ? '\u00A0' : char);
      let node = textNode;

      if (effects.includes('shake')) {
        const shakeSpan = document.createElement('span');
        shakeSpan.className = 'shake-letter';
        shakeSpan.style.animationDelay = delay + 'ms';
        shakeSpan.appendChild(node);
        node = shakeSpan;
      }
      if (effects.includes('wave')) {
        const waveSpan = document.createElement('span');
        waveSpan.className = 'wave-letter';
        waveSpan.style.animationDelay = delay + 'ms';
        waveSpan.appendChild(node);
        node = waveSpan;
      }
      if (scale !== 1) {
        const scaleSpan = document.createElement('span');
        scaleSpan.style.display = 'inline-block';
        scaleSpan.style.fontSize = scale + 'em';
        scaleSpan.appendChild(node);
        node = scaleSpan;
      }
      return node;
    }

    function parseCustomTags(text) {
      const frag = document.createDocumentFragment();
      const stack = [];
      let delayCount = 0;
      let i = 0;
      while (i < text.length) {
        if (text[i] === '<') {
          const open = text.slice(i).match(/^<\s*(shake|wave|scale)\s*([^>]*)>/i);
          const close = text.slice(i).match(/^<\s*\/\s*(shake|wave|scale)\s*>/i);
          if (open) {
            const tag = open[1].toLowerCase();
            if (tag === 'scale') {
              const factor = parseFloat(open[2]) || 1;
              stack.push({type: 'scale', factor});
            } else {
              stack.push({type: tag});
            }
            i += open[0].length;
            continue;
          } else if (close) {
            const tag = close[1].toLowerCase();
            for (let j = stack.length - 1; j >= 0; j--) {
              if (stack[j].type === tag) { stack.splice(j, 1); break; }
            }
            i += close[0].length;
            continue;
          }
        }
        const char = text[i];
        const hasWave = stack.some(e => e.type === 'wave');
        const hasShake = stack.some(e => e.type === 'shake');
        const effects = [];
        if (hasWave) effects.push('wave');
        if (hasShake) effects.push('shake');
        const scale = stack.filter(e => e.type === 'scale').reduce((s, e) => s * e.factor, 1);
        frag.appendChild(createSpan(char, effects, scale, delayCount * 50));
        delayCount++;
        i++;
      }
      return frag;
    }

    function updatePreview() {
      outputDiv.innerHTML = '';
      outputDiv.appendChild(parseCustomTags(inputArea.value));
    }

    inputArea.addEventListener('input', updatePreview);
    updatePreview();
  </script>
</body>
</html>
